<!DOCTYPE html>
<html>
<head>
  <title>Vocabulary</title>
  <style>
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: left;
    }
    th {
      background-color: #f2f2f2;
    }
    a.word-link {
      color: blue;
      text-decoration: underline;
    }
    .btn {
      padding: 5px 10px;
      margin: 5px;
      cursor: pointer;
    }
    .btn-delete {
      color: white;
      background-color: red;
    }
    .btn-batch-delete {
      color: white;
      background-color: orange;
    }
  </style>
</head>
<body>
  <h1>Vocabulary List</h1>

  <!-- Form to Add New Word -->
  <form id="vocabForm">
    <input type="text" id="word" placeholder="Word" required />
    <input type="text" id="meaning" placeholder="Meaning" required />
    <input type="text" id="example" placeholder="Example Sentence" />
    <input type="password" id="personalAccessToken" placeholder="Your Personal Access Token" required />
    <button type="submit">Add Word</button>
  </form>

  <!-- Batch Delete Button -->
  <button id="batchDeleteBtn" class="btn btn-batch-delete" style="display: none;">Delete Selected</button>

  <!-- Search Bar -->
  <input type="text" id="search" placeholder="Search words..." oninput="filterWords()" />

  <!-- Table to Display Vocabulary -->
  <table id="vocabularyTable">
    <thead>
      <tr>
        <th>Select</th>
        <th>Word</th>
        <th>Meaning</th>
        <th>Example</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody>
      <!-- Words will be dynamically added here -->
    </tbody>
  </table>

  <script>
    let vocabulary = [];

    // Fetch vocabulary.json and display it in a table
    async function loadVocabulary() {
      try {
        const response = await fetch('https://raw.githubusercontent.com/darwin-xu/vocabulary/main/vocabulary.json'); // No PAT required for public repo
        if (!response.ok) {
          throw new Error('Failed to fetch vocabulary');
        }
        vocabulary = await response.json();
        displayVocabulary(vocabulary);
      } catch (error) {
        alert('Error loading vocabulary. Please check if the repository is public.');
      }
    }

    // Display vocabulary in the table
    function displayVocabulary(words) {
      const tableBody = document.getElementById('vocabularyTable').querySelector('tbody');
      tableBody.innerHTML = ''; // Clear previous content
      words.forEach((entry, index) => {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td><input type="checkbox" data-index="${index}" /></td>
          <td><a href="https://dictionary.cambridge.org/dictionary/english/${encodeURIComponent(entry.word)}" target="_blank" class="word-link">${entry.word}</a></td>
          <td>${entry.meaning}</td>
          <td>${entry.example || 'N/A'}</td>
          <td><button class="btn btn-delete" onclick="deleteWord(${index})">Delete</button></td>
        `;
        tableBody.appendChild(row);
      });

      // Show or hide batch delete button
      document.getElementById('batchDeleteBtn').style.display = words.length > 0 ? 'inline-block' : 'none';
    }

    // Add new word
    document.getElementById('vocabForm').addEventListener('submit', async (e) => {
      e.preventDefault();

      const word = document.getElementById('word').value.trim();
      const meaning = document.getElementById('meaning').value.trim();
      const example = document.getElementById('example').value.trim();
      const token = document.getElementById('personalAccessToken').value.trim();

      // Check for duplicates
      if (vocabulary.some(entry => entry.word.toLowerCase() === word.toLowerCase())) {
        alert('This word already exists!');
        return;
      }

      if (!token) {
        alert('A Personal Access Token is required to submit a new word.');
        return;
      }

      // Add new word
      vocabulary.push({ word, meaning, example });

      // Sort vocabulary alphabetically by word
      vocabulary.sort((a, b) => a.word.localeCompare(b.word));

      await updateVocabulary('Add a new word', token);
    });

    // Delete a word
    async function deleteWord(index) {
      const token = document.getElementById('personalAccessToken').value.trim();
      if (!token) {
        alert('A Personal Access Token is required to delete a word.');
        return;
      }
      vocabulary.splice(index, 1);
      await updateVocabulary('Delete a word', token);
    }

    // Batch delete words
    document.getElementById('batchDeleteBtn').addEventListener('click', async () => {
      const token = document.getElementById('personalAccessToken').value.trim();
      if (!token) {
        alert('A Personal Access Token is required to delete words.');
        return;
      }
      const selected = document.querySelectorAll('input[type="checkbox"]:checked');
      const indicesToRemove = Array.from(selected).map(input => parseInt(input.dataset.index, 10));
      vocabulary = vocabulary.filter((_, index) => !indicesToRemove.includes(index));
      await updateVocabulary('Batch delete words', token);
    });

    // Update vocabulary.json
    async function updateVocabulary(message, token) {
      try {
        const response = await fetch('https://api.github.com/repos/darwin-xu/vocabulary/contents/vocabulary.json', {
          headers: { 'Authorization': `Bearer ${token}` },
        });

        if (!response.ok) {
          throw new Error('Error fetching file data');
        }

        const fileData = await response.json();
        const updatedContent = btoa(JSON.stringify(vocabulary, null, 2)); // Base64 encode JSON

        const updateResponse = await fetch('https://api.github.com/repos/darwin-xu/vocabulary/contents/vocabulary.json', {
          method: 'PUT',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            message,
            content: updatedContent,
            sha: fileData.sha, // Required to update file
          }),
        });

        if (!updateResponse.ok) {
          throw new Error('Error updating the file');
        }

        alert(`${message} successfully!`);
        loadVocabulary(); // Reload vocabulary
      } catch (error) {
        alert(`Error: ${error.message}`);
      }
    }

    // Search functionality
    function filterWords() {
      const query = document.getElementById('search').value.toLowerCase();
      const filtered = vocabulary.filter(entry => entry.word.toLowerCase().includes(query));
      displayVocabulary(filtered);
    }

    // Load vocabulary on page load
    loadVocabulary();
  </script>
</body>
</html>
